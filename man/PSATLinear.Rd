% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Linear_testing.R
\name{PSATLinear}
\alias{PSATLinear}
\title{Conduct Post Selection After qudratic Aggregation Testing inference

Inference for Normal Means after Aggregate Testing}
\usage{
PSATLinear(
  y,
  cov.mat,
  alpha = 0.05,
  a.vec = rep(1, ncol(cov.mat)),
  threshold.lower = -Inf,
  threshold.upper = Inf,
  contrast = NULL,
  alternative = NULL,
  test.type = c("symmetric", "UMPU"),
  pval.type = c("switch", "global", "hybrid", "polyhedral", "naive"),
  ci.type = pval.type,
  est.type = c("moment", "naive"),
  verbose = FALSE,
  zscore.bound = 5,
  samp.para = list(samp.size = 10000, burn.in = 200),
  optim.control = DEoptim::DEoptim.control()
)
}
\arguments{
\item{y}{The observed normal vector.}

\item{cov.mat}{The covariance matrix of \code{y}.}

\item{alpha}{Indicates the type I error level in which to find rejection areas and confidence intervals.}

\item{a.vec}{The test vector \eqn{a} of size \code{length(y)} used in the aggregate test, defaults to sum of all the test statistics.}

\item{threshold.lower}{The threshold \eqn{l < 0} used in the aggregate test.}

\item{threshold.upper}{The threshold  \eqn{u > 0} use in the aggregate test.
To specify a one-sided hypothesis testing, define the appropriate boundary as -Inf or Inf.}

\item{contrast}{An optional matrix of contrasts to be tested: must have number of columns
identical to the length of \code{y}. If left as \code{NULL}, the coordinates of \code{y} will be tested by default.}

\item{alternative}{A string.vector indicated the for which contrast what type of test to conduct
\code{'two.sided'}, \code{'less'} or \code{'greater'}. Should have the same length as number of contrasts.
Defaults to two.sided tests.}

\item{test.type}{Type of tests (UMPU and Symmetric), only relevant for two-sided testing.}

\item{pval.type}{Type of p-values to calculate for each contrast.
Options available are \code{'global', 'hybrid', 'polyhedral', 'naive'}.}

\item{ci.type}{Type of confidence intervals to create for each contrast.
Options available are \code{'global', 'hybrid', 'polyhedral', 'switch', 'naive'}.}

\item{est.type}{Type of point estimation, options available are \code{'moment', 'naive'}.}

\item{verbose}{Whether to report on the progress of the computation.
Defaults to the \code{pval.type}.}

\item{zscore.bound}{Number of the furthest bound before ignoring truncation and addressing the distribution as normal.
Defaults to the \code{pval.type}.}

\item{samp.para}{List of parameters for the tmg truncated normal sampler.
Contains two parameters \code{samp.size} and \code{burn.in}, for more details see \code{tmg::rtmg}.}

\item{optim.control}{allows the user to set some characteristics of the Differential Evolution optimization algorithm implemented in DEoptim.
For more details see code{\link[DEoptim]{DEoptim.control}}.}
}
\description{
\code{PSATLinear} is used to estimate a normal means model that was selected based
on a single linear aggregate test of the form:
\deqn{a'y > u or a'y < l,}
}
\details{
\code{PSATLinear}  The function is used to perform inference for normal mean vectors
that were selected based on a single linear aggregate test. To be exact, suppose
that \eqn{y ~ N(\mu,\Sigma)} and that we are interested in estimating \eqn{\mu}
only if we can determine that \eqn{\mu != 0} using an aggregate test of the form:
\eqn{a'y <l} or \eqn{a'y > u} for some predetermined constants \eqn{a, l, u}.

The \code{threshold} parameter specifies the constants \eqn{l<u} which are used
to threshold the aggregate test. If only a single number is provided, then the threshold
will be set according to test_direction:
\itemize{
\item lower: a'y < threshold
\item upper: a'y > threshold
\item two-sided a'y < -threshold, or a'y > threshold}
For more details see \href{https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssb.12318}{Post-selection estimation and testing following aggregate association tests}.
}
\examples{
\dontrun{
y         <- c(15, rnorm(p - 1))
cov.mat <- diag(p)
PSATLinear(y, cov.mat,
threshold.lower = qnorm(0.025, 0, sqrt(p)),
threshold.upper = qnorm(0.975, 0, sqrt(p)))
}

}
